<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flatulence Aurora</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a0a12;
    }
    
    #container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    
    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 1;
    }
    
    .fart {
      position: absolute;
      pointer-events: none;
      user-select: none;
      line-height: 1;
      z-index: 5;
    }
    
    #label {
      position: absolute;
      bottom: 20px;
      left: 20px;
      color: rgba(255, 255, 255, 0.3);
      font-family: monospace;
      font-size: 12px;
      z-index: 10;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="label">~ flatulence aurora ~</div>
  </div>

  <script>
    // Perlin noise implementation
    class PerlinNoise {
      constructor() {
        this.permutation = [];
        for (let i = 0; i < 256; i++) this.permutation[i] = i;
        for (let i = 255; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [this.permutation[i], this.permutation[j]] = [this.permutation[j], this.permutation[i]];
        }
        this.p = [...this.permutation, ...this.permutation];
      }

      fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
      lerp(a, b, t) { return a + t * (b - a); }
      grad(hash, x, y) {
        const h = hash & 3;
        const u = h < 2 ? x : y;
        const v = h < 2 ? y : x;
        return ((h & 1) ? -u : u) + ((h & 2) ? -v : v);
      }

      noise(x, y) {
        const X = Math.floor(x) & 255;
        const Y = Math.floor(y) & 255;
        x -= Math.floor(x);
        y -= Math.floor(y);
        const u = this.fade(x);
        const v = this.fade(y);
        const A = this.p[X] + Y, B = this.p[X + 1] + Y;
        return this.lerp(
          this.lerp(this.grad(this.p[A], x, y), this.grad(this.p[B], x - 1, y), u),
          this.lerp(this.grad(this.p[A + 1], x, y - 1), this.grad(this.p[B + 1], x - 1, y - 1), u),
          v
        );
      }
    }

    // Color palette for glows
    const GLOW_COLORS = [
      'rgba(144, 238, 144, 0.8)',
      'rgba(85, 107, 47, 0.8)',
      'rgba(154, 205, 50, 0.8)',
      'rgba(107, 142, 35, 0.8)',
      'rgba(139, 119, 101, 0.8)',
      'rgba(160, 82, 45, 0.8)',
      'rgba(222, 184, 135, 0.8)',
      'rgba(245, 245, 245, 0.8)',
      'rgba(176, 196, 172, 0.8)',
    ];

    const container = document.getElementById('container');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let width = window.innerWidth;
    let height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;

    const perlin = new PerlinNoise();
    const particles = [];
    const trails = [];
    let time = 0;

    const noiseScale = 0.002;
    const flowStrength = 3.0;

    function rgbFromGlow(colorStr) {
      const match = colorStr.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
      return match ? [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])] : [150, 150, 150];
    }

    function createParticle() {
      const element = document.createElement('div');
      element.className = 'fart';
      element.innerHTML = 'ðŸ’¨';
      
      const size = 72 + Math.random() * 108;
      element.style.fontSize = size + 'px';
      
      const particle = {
        element: element,
        x: Math.random() * width,
        y: Math.random() * height,
        speed: 1.2 + Math.random() * 3.5,
        size: size,
        colorIndex: Math.floor(Math.random() * GLOW_COLORS.length),
        alpha: 0.5 + Math.random() * 0.4,
        rotation: Math.random() * 360,
        rotationSpeed: (Math.random() - 0.5) * 1.5,
        life: 1,
        decay: 0.0002 + Math.random() * 0.0005,
        noiseOffsetX: Math.random() * 1000,
        noiseOffsetY: Math.random() * 1000,
        wobble: Math.random() * Math.PI * 2,
        wobbleSpeed: 0.015 + Math.random() * 0.025,
      };
      
      container.appendChild(element);
      return particle;
    }

    function resetParticle(p) {
      p.x = Math.random() * width;
      p.y = Math.random() * height;
      p.life = 1;
      p.alpha = 0.5 + Math.random() * 0.4;
      p.noiseOffsetX = Math.random() * 1000;
      p.noiseOffsetY = Math.random() * 1000;
    }

    // Initialize particles
    const particleCount = Math.min(50, Math.floor((width * height) / 30000));
    for (let i = 0; i < particleCount; i++) {
      particles.push(createParticle());
    }

    function drawBackground() {
      // Base gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, height);
      gradient.addColorStop(0, '#0a0a12');
      gradient.addColorStop(0.3, '#1a1a2e');
      gradient.addColorStop(0.6, '#16213e');
      gradient.addColorStop(1, '#0f0f1a');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, width, height);

      // Aurora waves
      const waveColors = [
        [144, 238, 144],
        [85, 107, 47],
        [154, 205, 50],
        [139, 119, 101],
        [176, 196, 172],
      ];

      for (let i = 0; i < 5; i++) {
        ctx.beginPath();
        ctx.moveTo(0, height * 0.3);
        
        for (let x = 0; x <= width; x += 10) {
          const y = height * 0.3 + 
            Math.sin(x * 0.005 + time * 0.001 + i) * 50 +
            Math.sin(x * 0.002 + time * 0.0005) * 100 +
            perlin.noise(x * 0.003, time * 0.0002 + i) * 80;
          ctx.lineTo(x, y);
        }
        
        ctx.lineTo(width, height);
        ctx.lineTo(0, height);
        ctx.closePath();
        
        const color = waveColors[i % waveColors.length];
        const waveGradient = ctx.createLinearGradient(0, height * 0.2, 0, height * 0.8);
        waveGradient.addColorStop(0, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.03)`);
        waveGradient.addColorStop(0.5, `rgba(${color[0]}, ${color[1]}, ${color[2]}, 0.07)`);
        waveGradient.addColorStop(1, 'transparent');
        ctx.fillStyle = waveGradient;
        ctx.fill();
      }

      // Draw trails
      for (let i = trails.length - 1; i >= 0; i--) {
        const trail = trails[i];
        trail.alpha -= 0.015;
        trail.size *= 0.98;
        
        if (trail.alpha <= 0) {
          trails.splice(i, 1);
        } else {
          ctx.beginPath();
          ctx.arc(trail.x, trail.y, trail.size, 0, Math.PI * 2);
          const [r, g, b] = trail.rgb;
          ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${trail.alpha * 0.4})`;
          ctx.fill();
        }
      }
    }

    function animate() {
      time++;
      
      drawBackground();
      
      particles.forEach(p => {
        const noiseVal = perlin.noise(
          (p.x + p.noiseOffsetX) * noiseScale,
          (p.y + p.noiseOffsetY) * noiseScale + time * 0.0001
        );
        
        const angle = noiseVal * Math.PI * 4;
        
        p.wobble += p.wobbleSpeed;
        const wobbleX = Math.sin(p.wobble) * 1.0;
        const wobbleY = Math.cos(p.wobble * 0.7) * 0.6;
        
        const oldX = p.x;
        const oldY = p.y;
        
        p.x += (Math.cos(angle) * p.speed * flowStrength + wobbleX);
        p.y += (Math.sin(angle) * p.speed * flowStrength + wobbleY - 0.6);
        
        p.rotation += p.rotationSpeed;
        p.life -= p.decay;
        
        // Add trail
        if (Math.random() > 0.6) {
          trails.push({
            x: oldX + p.size * 0.4,
            y: oldY + p.size * 0.4,
            size: p.size * 0.2,
            alpha: 0.5,
            rgb: rgbFromGlow(GLOW_COLORS[p.colorIndex]),
          });
          
          if (trails.length > 200) {
            trails.shift();
          }
        }
        
        // Wrap around
        if (p.x < -200) p.x = width + 200;
        if (p.x > width + 200) p.x = -200;
        if (p.y < -200) p.y = height + 200;
        if (p.y > height + 200) p.y = -200;
        
        if (p.life <= 0) resetParticle(p);
        
        // Update DOM element
        const pulse = 0.85 + Math.sin(time * 0.002 + p.noiseOffsetX) * 0.15;
        const currentAlpha = p.alpha * p.life * pulse;
        const glowSize = 25 + Math.sin(time * 0.003 + p.noiseOffsetY) * 12;
        
        p.element.style.transform = `translate(${p.x}px, ${p.y}px) rotate(${p.rotation}deg)`;
        p.element.style.opacity = currentAlpha;
        p.element.style.filter = `drop-shadow(0 0 ${glowSize}px ${GLOW_COLORS[p.colorIndex]}) drop-shadow(0 0 ${glowSize * 2}px ${GLOW_COLORS[p.colorIndex]})`;
      });
      
      requestAnimationFrame(animate);
    }

    window.addEventListener('resize', () => {
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width;
      canvas.height = height;
    });

    animate();
  </script>
</body>
</html>